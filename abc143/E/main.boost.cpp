#include <bits/stdc++.h>
using namespace std;
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/floyd_warshall_shortest.hpp>

using Graph = boost::adjacency_list<boost::listS, boost::vecS, boost::undirectedS, boost::no_property,
                                    boost::property<boost::edge_weight_t, long long>>;
using Edge = pair<long long, long long>;
using Vertex = boost::graph_traits<Graph>::vertex_descriptor;
using DistanceMatrix = map<Vertex, map<Vertex, long long>>;

void solve(long long N, long long M, long long L, std::vector<long long> A, std::vector<long long> B,
           std::vector<long long> C, long long Q, std::vector<long long> s, std::vector<long long> t) {
  vector<Edge> edges;
  vector<long long> LC;
  for (long long i = 0; i < M; i++) {
    if (C[i] > L)
      continue;
    edges.push_back(make_pair(A[i] - 1, B[i] - 1));
    LC.push_back(C[i]);
  }
  const Graph g(edges.begin(), edges.end(), LC.begin(), N);
  DistanceMatrix d;
  boost::floyd_warshall_all_pairs_shortest_paths(g, d);
  vector<Edge> xe;
  vector<long long> xc;
  for (long long i = 0; i < N - 1; i++) {
    for (long long j = i + 1; j < N; j++) {
      if (d[i][j] <= L) {
        xe.push_back(make_pair(i, j));
        xc.push_back(1);
      }
    }
  }
  const Graph gx(xe.begin(), xe.end(), xc.begin(), N);
  DistanceMatrix dx;
  boost::floyd_warshall_all_pairs_shortest_paths(gx, dx);
  for (long long i = 0; i < Q; i++) {
    long long di = dx[s[i] - 1][t[i] - 1];
    cout << (di < 1e17 ? di - 1 : -1) << endl;
  }
}

// Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You
// use the default template now. You can remove this line by using your custom
// template)
int main() {
  long long N;
  scanf("%lld", &N);
  long long M;
  scanf("%lld", &M);
  long long L;
  scanf("%lld", &L);
  std::vector<long long> A(M);
  std::vector<long long> B(M);
  std::vector<long long> C(M);
  for (int i = 0; i < M; i++) {
    scanf("%lld", &A[i]);
    scanf("%lld", &B[i]);
    scanf("%lld", &C[i]);
  }
  long long Q;
  scanf("%lld", &Q);
  std::vector<long long> s(Q);
  std::vector<long long> t(Q);
  for (int i = 0; i < Q; i++) {
    scanf("%lld", &s[i]);
    scanf("%lld", &t[i]);
  }
  solve(N, M, L, std::move(A), std::move(B), std::move(C), Q, std::move(s), std::move(t));
  return 0;
}
