#include <bits/stdc++.h>
using namespace std;
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>

// struct Edge {
//   int to;
//   int weight;
//   Edge(int t, int w) : to(t), weight(w) {}
// };
// using Graph = vector<vector<Edge>>;
using BGraph =
    boost::adjacency_list<boost::listS, boost::vecS, boost::undirectedS,
                          boost::no_property,
                          boost::property<boost::edge_weight_t, long long>>;
using Edge = pair<long long, long long>;
using Vertex = boost::graph_traits<BGraph>::vertex_descriptor;

void solve(long long N, long long M, long long L, std::vector<long long> A,
           std::vector<long long> B, std::vector<long long> C, long long Q,
           std::vector<long long> s, std::vector<long long> t) {
  vector<Edge> edges;
  for (long long i = 0; i < M; i++) {
    if (C[i] > L) {
      edges[i] = make_pair(N, N);
    }
    edges[i] = make_pair(A[i] - 1, B[i] - 1);
  }
  const BGraph g(edges.begin(), edges.end(), C.begin(), N);
  vector<Vertex> parents(N);
  vector<long long> distance(N);

  for (long long i = 0; i < Q; i++) {
    long long from = s[i] - 1;
    long long to = t[i] - 1;
    boost::dijkstra_shortest_paths(
        g, from,
        boost::predecessor_map(&parents[0]).distance_map(&distance[0]));
    if (parents[to] == to) {
      cout << -1 << endl;
      continue;
    }
    cout << ((distance[to] + 1) / L) << endl;
  }
}

// Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You
// use the default template now. You can remove this line by using your custom
// template)
int main() {
  long long N;
  scanf("%lld", &N);
  long long M;
  scanf("%lld", &M);
  long long L;
  scanf("%lld", &L);
  std::vector<long long> A(M);
  std::vector<long long> B(M);
  std::vector<long long> C(M);
  for (int i = 0; i < M; i++) {
    scanf("%lld", &A[i]);
    scanf("%lld", &B[i]);
    scanf("%lld", &C[i]);
  }
  long long Q;
  scanf("%lld", &Q);
  std::vector<long long> s(Q);
  std::vector<long long> t(Q);
  for (int i = 0; i < Q; i++) {
    scanf("%lld", &s[i]);
    scanf("%lld", &t[i]);
  }
  solve(N, M, L, std::move(A), std::move(B), std::move(C), Q, std::move(s),
        std::move(t));
  return 0;
}
